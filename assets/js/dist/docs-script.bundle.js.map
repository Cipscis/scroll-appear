{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/scroll-appear/./node_modules/@cipscis/throttle/dist/throttle.js","webpack://@cipscis/scroll-appear/./node_modules/@cipscis/debounce/dist/debounce.js","webpack://@cipscis/scroll-appear/./src/eventListenerPassiveSupport.ts","webpack://@cipscis/scroll-appear/./src/constants.ts","webpack://@cipscis/scroll-appear/./src/elements.ts","webpack://@cipscis/scroll-appear/./src/viewport.ts","webpack://@cipscis/scroll-appear/./src/scroll-appear.ts","webpack://@cipscis/scroll-appear/./src/ScrollAppearQueue.ts","webpack://@cipscis/scroll-appear/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["/**\r\n * Create a version of fn that will only execute if it\r\n * hasn't been called successfully within the last delay ms\r\n *\r\n * @param {Function} fn - A function to throttle\r\n * @param {number} delay - The duration to wait before the function can be called again (ms)\r\n */\r\nconst throttle = function (fn, delay) {\r\n    // Use ReturnType<typeof setTimeout> for support across ES and NodeJS environments\r\n    let timeout;\r\n    return function (...args) {\r\n        if (!timeout) {\r\n            const returnVal = fn.apply(this, args);\r\n            timeout = setTimeout(() => {\r\n                timeout = undefined;\r\n            }, delay);\r\n            return returnVal;\r\n        }\r\n    };\r\n};\r\nexport { throttle };\r\nexport default throttle;\r\n//# sourceMappingURL=throttle.js.map","/**\r\n * Create a version of fn that will execute only after\r\n * no attempt to call it has been made for delay ms.\r\n * The debounced function returns a Promise that\r\n * resolves to the value returned by fn.\r\n *\r\n * Note that this will uncouple the callback from user\r\n * input, if used as an event callback. This can cause\r\n * browsers to attempt to block certain behaviour.\r\n *\r\n * This throttling is useful, for example, for waiting until\r\n * the user has stopped typing before executing a keyup callback.\r\n *\r\n * @param {Function} fn - A function to debounce\r\n * @param {number} delay - The duration to wait before calling the function (ms)\r\n */\r\nconst debounce = function (fn, delay) {\r\n    // Keep track of the timeout, Promise, and the Promise's resolver across multiple calls\r\n    // This lets later calls in the same queue know about the previous call,\r\n    // to cancel its timeout and use the same promise and resolution\r\n    // Use ReturnType<typeof setTimeout> for support across ES and NodeJS environments\r\n    let timeout;\r\n    let promise;\r\n    let res;\r\n    return function (...args) {\r\n        const scheduleResolution = (resolve) => {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n            }\r\n            timeout = setTimeout(() => {\r\n                timeout = undefined;\r\n                promise = undefined;\r\n                res = undefined;\r\n                resolve(fn.apply(this, args));\r\n            }, delay);\r\n        };\r\n        if (res) {\r\n            scheduleResolution(res);\r\n        }\r\n        else {\r\n            promise = new Promise((resolve, reject) => {\r\n                res = resolve;\r\n                scheduleResolution(res);\r\n            });\r\n        }\r\n        // There is no type guard for promise on the `if (res)` path,\r\n        // but if res is not undefined, then neither is promise\r\n        return promise;\r\n    };\r\n};\r\nexport { debounce };\r\nexport default debounce;\r\n//# sourceMappingURL=debounce.js.map","/**\n * Some older browsers don't support passing an options object to `addEventListener`,\n * instead expecting a booolean value to tell them if the event is passive. To detect\n * how the current browser expects to tell if an event is passive, temporarily bind\n * a dummy event that passes an object with a getter in its `passive` property so we\n * can detect if the browser tried to access it.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#safely_detecting_option_support\n */\nlet passiveSupported = false;\ntry {\n\tconst options = {\n\t\tget passive() {\n\t\t\tpassiveSupported = true;\n\t\t\treturn false;\n\t\t},\n\t} as EventListenerOptions;\n\n\tconst noop = () => {};\n\n\twindow.addEventListener('test', noop, options);\n\twindow.removeEventListener('test', noop);\n} catch (e) {\n\tpassiveSupported = false;\n}\n\nexport default passiveSupported;\n","export enum ScrollAppearState {\n\tHIDDEN = 'hidden',\n\tVISIBLE = 'visible',\n}\n\nexport const dataAttributes = {\n\tstate: 'data-scroll-appear-state',\n\tdelay: 'data-scroll-appear-delay',\n} as const;\n\nexport const selectors = {\n\tuninitialised: `.js-scroll-appear:not([${dataAttributes.state}])`,\n\thidden: `.js-scroll-appear[${dataAttributes.state}=\"${ScrollAppearState.HIDDEN}\"]`,\n\tvisible: `.js-scroll-appear[${dataAttributes.state}=\"${ScrollAppearState.VISIBLE}\"]`,\n} as const;\n","import  {\n\tScrollAppearState,\n\tselectors,\n\tdataAttributes,\n} from './constants.js';\n\nimport { isElementInViewport } from './viewport.js';\n\n/**\n * Find all Elements in the viewport, and show them.\n */\nexport function showElementsInViewport(): void {\n\tconst $hiddenElements = Array.from(document.querySelectorAll(selectors.hidden));\n\n\tconst $elementsToAppear = $hiddenElements.filter(isElementInViewport);\n\n\t$elementsToAppear.forEach(showElement);\n}\n\n/**\n * Hide a specific element\n */\nexport function hideElement($element: Element): void {\n\t$element.setAttribute(dataAttributes.state, ScrollAppearState.HIDDEN);\n}\n\n/**\n * Show a specific Element.\n */\nexport function showElement($element: Element): void {\n\t$element.setAttribute(dataAttributes.state, ScrollAppearState.VISIBLE);\n}\n","/**\n * Checks if an Element is in the viewport. Only checks vertical boundaries, not horizontal.\n */\nexport function isElementInViewport($element: Element, threshold: number = 0): boolean {\n\tconst windowHeight = window.innerHeight;\n\tconst maxThreshold = (windowHeight / 2) - 50;\n\tif (threshold > maxThreshold) {\n\t\tthreshold = maxThreshold;\n\t}\n\n\tconst coords = $element.getBoundingClientRect();\n\n\tconst viewportHeight = window.innerHeight || document.documentElement.clientWidth;\n\tconst viewportTop = threshold;\n\tconst viewportBottom = viewportHeight - threshold;\n\n\t// Is the bottom of the element below the top of the viewport?\n\tconst belowTop = coords.bottom >= viewportTop;\n\n\t// Is the top of the element above the bottom of the viewport?\n\tconst aboveBottom = coords.top <= viewportBottom;\n\n\tconst inViewport = belowTop && aboveBottom;\n\n\treturn inViewport;\n}\n","import { throttle } from '@cipscis/throttle';\nimport { debounce } from '@cipscis/debounce';\n\nimport passiveSupported from './eventListenerPassiveSupport.js';\n\nimport { selectors } from './constants.js';\nimport { hideElement } from './elements.js';\nimport { isElementInViewport } from './viewport.js';\n\nimport { ScrollAppearQueue } from './ScrollAppearQueue.js';\n\n/** (milliseconds) Throttle/debounce delay for scroll and resize events */\nconst delay = 100;\n\nconst queue = new ScrollAppearQueue();\n\n/**\n * Initialise ScrollAppear for a particular set of elements\n */\nexport function init($container: Element | Document = document): void {\n\t_initElements($container);\n\n\t_initEvents();\n}\n\n/**\n * Find all elements and hide them. Then, show any elements within the viewport\n */\nfunction _initElements($container: Element | Document = document): void {\n\tconst $elements = $container.querySelectorAll(selectors.uninitialised);\n\n\t$elements.forEach(hideElement);\n\n\t_queueElementsInViewport();\n}\n\n/**\n * Show elements in the viewport any time the viewport changes through\n * scrolling or resizing.\n */\nfunction _initEvents(): void {\n\tconst passiveOptions = passiveSupported ? { passive: true } : true;\n\n\tconst throttledShow = throttle(_queueElementsInViewport, delay);\n\tconst debouncedShow = debounce(_queueElementsInViewport, delay);\n\n\twindow.addEventListener('scroll', throttledShow, passiveOptions);\n\twindow.addEventListener('scroll', debouncedShow, passiveOptions);\n\n\twindow.addEventListener('resize', throttledShow, passiveOptions);\n\twindow.addEventListener('resize', debouncedShow, passiveOptions);\n\n\tconst throttledCatchUp = throttle(_catchUpQueue, delay);\n\tconst debouncedCatchUp = debounce(_catchUpQueue, delay);\n\n\twindow.addEventListener('scroll', throttledCatchUp, passiveOptions);\n\twindow.addEventListener('scroll', debouncedCatchUp, passiveOptions);\n\n\twindow.addEventListener('resize', throttledCatchUp, passiveOptions);\n\twindow.addEventListener('resize', debouncedCatchUp, passiveOptions);\n}\n\n/**\n * Add all hidden elements in the viewport to the queue\n */\nfunction _queueElementsInViewport(): void {\n\tconst $hiddenElements = document.querySelectorAll(selectors.hidden);\n\n\tconst $hiddenElementsInViewport = Array.from($hiddenElements).filter(isElementInViewport);\n\n\t$hiddenElementsInViewport.forEach(($element) => queue.push($element));\n}\n\n/**\n * Tell the queue to \"catch up\" with the viewport\n */\nfunction _catchUpQueue(): void {\n\tqueue.catchUp();\n}\n","import { dataAttributes } from './constants.js';\nimport { showElement } from './elements.js';\nimport { isElementInViewport } from './viewport.js';\n\ninterface ScrollAppearQueueItem {\n\t$element: Element,\n\tdelay: number,\n}\n\n// TODO: Make the first item appear immediately, so its delay affects the item after it instead\n// TODO: Allow for multiple queues, based either on an ID in a data attribute or a containing element\n\nexport class ScrollAppearQueue {\n\tconstructor() {\n\t\tthis.items = [];\n\t\tthis.timeout = null;\n\t}\n\n\titems: ScrollAppearQueueItem[];\n\n\ttimeout: ReturnType<typeof setTimeout> | null;\n\n\t/**\n\t * Add an item to the end of the queue if it's not in there already\n\t */\n\tpush($element: Element): void {\n\t\tif (this.#isInQueue($element)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst delay = Number($element.getAttribute(dataAttributes.delay)) || 0;\n\n\t\tconst item: ScrollAppearQueueItem = {\n\t\t\t$element,\n\t\t\tdelay,\n\t\t};\n\n\t\tthis.items.push(item);\n\t\tthis.#scheduleExecution();\n\t}\n\n\t/**\n\t * Immediately show any elements that have left the viewport\n\t */\n\tcatchUp(): void {\n\t\tfor (const [i, item] of this.items.entries()) {\n\t\t\tif (isElementInViewport(item.$element) === false) {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tthis.#execute();\n\t\t\t\t} else {\n\t\t\t\t\tthis.items.splice(i, 1);\n\t\t\t\t\tshowElement(item.$element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if an element is already in the queue\n\t */\n\t#isInQueue($element: Element): boolean {\n\t\tconst item = this.items.find((item) => item.$element === $element);\n\n\t\treturn !!item;\n\t}\n\n\t/**\n\t * Schedule the execution of the first item in the queue\n\t */\n\t#scheduleExecution(): void {\n\t\tconst nextItem = this.items[0];\n\n\t\tif (nextItem && this.timeout === null) {\n\t\t\tthis.timeout = setTimeout(() => this.#execute(), nextItem.delay);\n\t\t}\n\t}\n\n\t/**\n\t * Make the first item in the queue appear\n\t */\n\t#execute(): void {\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout);\n\t\t}\n\t\tthis.timeout = null;\n\n\t\tconst nextItem = this.items.shift();\n\n\t\tif (nextItem) {\n\t\t\tshowElement(nextItem.$element);\n\t\t\tthis.#scheduleExecution();\n\t\t}\n\t}\n}\n","import { init } from '@cipscis/scroll-appear';\n\ninit();\n"],"names":["throttle","fn","delay","timeout","args","returnVal","apply","this","setTimeout","undefined","debounce","promise","res","scheduleResolution","resolve","clearTimeout","Promise","reject","passiveSupported","options","passive","noop","window","addEventListener","removeEventListener","e","ScrollAppearState","dataAttributes","uninitialised","hidden","HIDDEN","visible","VISIBLE","hideElement","$element","setAttribute","showElement","threshold","maxThreshold","innerHeight","coords","getBoundingClientRect","viewportTop","viewportBottom","document","documentElement","clientWidth","belowTop","bottom","aboveBottom","top","queue","constructor","items","push","Number","getAttribute","item","catchUp","i","entries","splice","find","nextItem","shift","_queueElementsInViewport","$hiddenElements","querySelectorAll","Array","from","filter","forEach","_catchUpQueue","$container","_initElements","passiveOptions","throttledShow","debouncedShow","throttledCatchUp","debouncedCatchUp","_initEvents","init"],"sourceRoot":""}