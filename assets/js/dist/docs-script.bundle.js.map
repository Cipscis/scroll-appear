{"version":3,"file":"docs-script.bundle.js","mappings":"mBAYA,MAAMA,EAAuB,SAAUC,EAAIC,GAEvC,IAAIC,EAAkB,KAClBC,EAAkB,KACtB,OAAO,YAAaC,GACZF,GACIC,GACAE,aAAaF,GAEjBA,EAAkBG,YAAW,KACzBN,EAAGO,MAAMC,KAAMJ,GACfD,EAAkB,OACnBF,KAGHD,EAAGO,MAAMC,KAAMJ,GACfF,EAAkBI,YAAW,KACzBJ,EAAkB,OACnBD,MCrBf,IAAIQ,GAAmB,EACvB,IACC,MAAMC,EAAU,CACXC,cAEH,OADAF,GAAmB,GACZ,IAIHG,EAAO,OAEbC,OAAOC,iBAAiB,OAAQF,EAAMF,GACtCG,OAAOE,oBAAoB,OAAQH,GAClC,MAAOI,GACRP,GAAmB,EAGpB,UCvBaQ,EACN,oBAIMC,EACL,2BCTR,IAAYC,GAAZ,SAAYA,GACX,gCACA,kBACA,wBACA,oBAJD,CAAYA,IAAAA,EAAiB,KCGtB,MAAMC,EACZ,GACA,GACA,GACA,GAEAC,cACCb,MAAK,EAAS,GACdA,MAAK,EAAW,KAChBA,MAAK,EAAuB,KAC5BA,MAAK,EAAiB,EAMvBc,KAAKC,GACAf,MAAK,EAAWe,IAKhBA,EAAKC,aAAeL,EAAkBM,SACzCjB,MAAK,EAAOc,KAAKC,GACjBf,MAAK,KAOPkB,UACC,IAAK,IAAIC,EAAI,EAAGA,EAAInB,MAAK,EAAOoB,OAAQD,IAAK,CAC5C,MAAMJ,EAAOf,MAAK,EAAOmB,IAEG,IAAxBJ,EAAKM,iBACE,IAANF,EAEHnB,MAAK,KAILA,MAAK,EAAOsB,OAAOH,EAAG,GACtBJ,EAAKQ,UAKNJ,GAAK,IAQR,GAAWJ,GAGV,OAFgBf,MAAK,EAAOwB,SAAST,GAQtC,KAE4B,IAAvBf,MAAK,EAAOoB,OASM,OAAlBpB,MAAK,IAITA,MAAK,EAAWF,YAAW,IAAME,MAAK,KAAoBA,MAAK,IAZ9DA,MAAK,EAAuBF,YAAW,KACtCE,MAAK,EAAiB,EACtBA,MAAK,EAAuB,OAC1BA,MAAK,GAeV,KAGKA,MAAK,IACRH,aAAaG,MAAK,GAClBA,MAAK,EAAuB,MAKzBA,MAAK,GACRH,aAAaG,MAAK,GAEnBA,MAAK,EAAW,KAEhB,IAAIyB,EAAYzB,MAAK,EAAO0B,QAG5B,KAAOD,GAAWT,aAAeL,EAAkBgB,SAClDF,EAAYzB,MAAK,EAAO0B,QAGrBD,IACHA,EAAUF,SACVvB,MAAK,EAAiByB,EAAUhC,MAChCO,MAAK,MChHR,MAAM4B,EAA8D,IAAIC,IAElEC,EAAc,IAAIlB,EAGjB,SAASmB,EAASC,EAA0CC,UAClE,MAAMC,EAAQN,EAAOO,IAAIH,IAAe,IAAIpB,EAM5C,OAJ+B,IAA3BgB,EAAOQ,IAAIJ,IACdJ,EAAOS,IAAIL,EAAYE,GAGjBA,EAGD,SAASI,IACf,MAAMC,EAAiC,GAEvC,IAAK,MAAMC,KAAOZ,EAAOa,SACxBF,EAAUzB,KAAK0B,GAGhB,OAAOD,EAnBRX,EAAOS,IAAIJ,SAAUH,GCUrB,MAAMY,EAAoD,IAAIb,IAQvD,SAASc,EAAoBC,GACnC,MAAMC,EAAeH,EAAkBP,IAAIS,GAC3C,OAAIC,GAIY,IAAIC,EAAiBF,GAItC,MAAME,EACL,GAEAjC,YAAY+B,GACX,GAAIF,EAAkBN,IAAIQ,GACzB,MAAM,IAAIG,MAAM,oEAEhBL,EAAkBL,IAAIO,EAAU5C,MAGjCA,MAAK,EAAY4C,EAEb5C,KAAKgB,aAAeL,EAAkBqC,eACzChD,MAAK,EAAUW,EAAkBM,QAIlCjB,MAAK,EAAUM,iBAAiB,WAAW,IAAMN,KAAKuB,UAAU,CAAE0B,MAAM,IAGrExD,YACH,OAAOyD,OAAOlD,MAAK,EAAUmD,aJ5CvB,8BI4C0D,EAOjE9B,aAAa+B,EAAoB,GAChC,MACMC,EADehD,OAAOiD,YACS,EAAK,GACtCF,EAAYC,IACfD,EAAYC,GAGb,MAAME,EAASvD,MAAK,EAAUwD,wBAGxBC,EAAcL,EACdM,GAFiBrD,OAAOiD,aAAerB,SAAS0B,gBAAgBC,aAE9BR,EAGlCS,EAAWN,EAAOO,QAAUL,EAG5BM,EAAcR,EAAOS,KAAON,EAIlC,OAFmBG,GAAYE,EAQhCxC,SACKvB,KAAKgB,aAAeL,EAAkBgB,UAItCsC,WAAW,4BAA4BC,QAE1ClE,MAAK,EAAUW,EAAkBgB,UAEjC3B,MAAK,EAAUW,EAAkBwD,WAE2B,OAAxDC,iBAAiBpE,MAAK,GAAWqE,mBAEpCrE,MAAK,EAAUM,iBAAiB,iBAAiB,IAAMN,MAAK,EAAUW,EAAkBgB,UAAU,CAAEsB,MAAM,IAG1GjD,MAAK,EAAUW,EAAkBgB,WAQpC,GAAU2C,GACTtE,MAAK,EAAUuE,aAAa7D,EAAkB4D,GAM/CtD,WACC,MAAMsD,EAAQtE,MAAK,EAAUmD,aAAazC,GAE1C,OHnHkC8D,EGmHVF,EHlHVG,OAAOhC,OAAO9B,GAIAa,SAASgD,GG+G7BF,EAEA3D,EAAkBqC,cHtHrB,IAA6BwB,EG6HnC,KAEC,MAAME,EAAU1E,MAAK,EAAUmD,aJ3HzB,4BI4HN,GAAIuB,EACH,OAAO3C,EAAS2C,GAIjB,MAAMC,EAAa3E,MAAK,EAAU4E,QJvIxB,gCIwIV,OAAID,EACI5C,EAAS4C,GAIV5C,IAMRG,QACelC,MAAK,IAEbc,KAAKd,OAiBoB,IAAI6E,kBAQrC,SAA+BC,EAA6BC,GAI3D,IAAK,MAAMnC,KAAYF,EAAkBsC,QACC,IAArC/C,SAASgD,KAAKC,SAAStC,IAC1BF,EAAkByC,OAAOvC,MAKHwC,QAAQnD,SAAU,CAC1CoD,WAAW,EACXC,SAAS,ICnLV,MAMMP,EAAW,IAAIF,kBA0CrB,SAA2BC,EAA6BS,GACvD,IAAIC,GAAa,EAEjB,IAAK,MAAMC,KAAYX,EACtB,GAAIW,EAASC,WAAWtE,OAAS,EAAG,CACnCoE,GAAa,EACb,MAIF,IAAmB,IAAfA,EAAqB,CACxB,MAAMG,EAAY1D,SAAS2D,iBAAiBnF,GACxCkF,EAAUvE,OAAS,GACtByE,EAAmBF,OAStB,SAASE,EAAmBF,GAC3B,MAAMG,EAeP,SAAuBH,GAOtB,OANKA,IACJA,EAAY1D,SAAS2D,iBAAiBnF,IAGzBsF,MAAMC,KAAKL,GAAWnD,IAAIG,GApB1BsD,CAAcN,IA4B7B,SAAqCG,GAChBA,EAAMI,QAAQnF,GAASA,EAAKC,aAAeL,EAAkBM,SAEvCiF,QAAQnF,GAASA,EAAKM,iBAE1C8E,SAASpF,GAASA,EAAKmB,UAhC7CkE,CAA4BN,GAM7B,SAASO,EAAwB7F,GAChCqF,IA+BD,SAASS,IACR,MAAM1E,EAASU,IAEf,IAAK,MAAMJ,KAASN,EACnBM,EAAMhB,UAtGP2E,IASD,WACC,MAAMU,GAAiB,GAAmB,CAAEpG,SAAS,GAE/CqG,EAAgBjH,EAAqB8G,EAxB9B,KA0BbhG,OAAOC,iBAAiB,SAAUkG,EAAeD,GACjDlG,OAAOC,iBAAiB,SAAUkG,EAAeD,GAEjD,MAAME,EAAmBlH,EAAqB+G,EA7BjC,KA+BbjG,OAAOC,iBAAiB,SAAUmG,EAAkBF,GACpDlG,OAAOC,iBAAiB,SAAUmG,EAAkBF,GAnBpDG,GA0BA3B,EAASK,QAAQnD,SAAU,CAC1BoD,WAAW,EACXC,SAAS,ICrDXjF,OAAOP,YAAW,KACjB,MAAM8C,EAAWX,SAAS0E,cAAc,OACxC/D,EAASgE,UAAUC,IAAI,oBACvBjE,EAASgE,UAAUC,IAAI,WACvBjE,EAAS2B,aAAa,2BAA4B,iBAElD,MAAMuC,EAAS7E,SAAS2D,iBAAiB,kBACrCkB,EAAO1F,QACV0F,EAAOA,EAAO1F,OAAO,GAAG2F,YAAYnE,KAEnC,M","sources":["webpack://@cipscis/scroll-appear/./node_modules/@cipscis/throttle-with-debounce/dist/throttle-with-debounce.js","webpack://@cipscis/scroll-appear/./src/eventListenerPassiveSupport.ts","webpack://@cipscis/scroll-appear/./src/domMap.ts","webpack://@cipscis/scroll-appear/./src/ScrollAppearState.ts","webpack://@cipscis/scroll-appear/./src/ScrollAppearQueue.ts","webpack://@cipscis/scroll-appear/./src/queues.ts","webpack://@cipscis/scroll-appear/./src/ScrollAppearItem.ts","webpack://@cipscis/scroll-appear/./src/scroll-appear.ts","webpack://@cipscis/scroll-appear/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["/**\r\n * Create a version of fn that will only execute if it\r\n * hasn't been called successfully within the last delay ms,\r\n * and will also execute an additional time after it has\r\n * stopped being called if it was called more than once.\r\n *\r\n * This is useful for binding callbacks to events such as\r\n * scroll or resize.\r\n *\r\n * @param {Function} fn - A function to throttle\r\n * @param {number} delay - The duration to wait before the function can be called again (ms)\r\n */\r\nconst throttleWithDebounce = function (fn, delay) {\r\n    // Use ReturnType<typeof setTimeout> for support across ES and NodeJS environments\r\n    let throttleTimeout = null;\r\n    let debounceTimeout = null;\r\n    return function (...args) {\r\n        if (throttleTimeout) {\r\n            if (debounceTimeout) {\r\n                clearTimeout(debounceTimeout);\r\n            }\r\n            debounceTimeout = setTimeout(() => {\r\n                fn.apply(this, args);\r\n                debounceTimeout = null;\r\n            }, delay);\r\n        }\r\n        else {\r\n            fn.apply(this, args);\r\n            throttleTimeout = setTimeout(() => {\r\n                throttleTimeout = null;\r\n            }, delay);\r\n        }\r\n    };\r\n};\r\nexport { throttleWithDebounce };\r\nexport default throttleWithDebounce;\r\n//# sourceMappingURL=throttle-with-debounce.js.map","/**\n * Some older browsers don't support passing an options object to `addEventListener`,\n * instead expecting a booolean value to tell them if the event is passive. To detect\n * how the current browser expects to tell if an event is passive, temporarily bind\n * a dummy event that passes an object with a getter in its `passive` property so we\n * can detect if the browser tried to access it.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#safely_detecting_option_support\n */\nlet passiveSupported = false;\ntry {\n\tconst options = {\n\t\tget passive() {\n\t\t\tpassiveSupported = true;\n\t\t\treturn false;\n\t\t},\n\t} as EventListenerOptions;\n\n\tconst noop = () => {};\n\n\twindow.addEventListener('test', noop, options);\n\twindow.removeEventListener('test', noop);\n} catch (e) {\n\tpassiveSupported = false;\n}\n\nexport default passiveSupported;\n","// These objects contain constants used to map information\n// between the DOM and our model.\n\nexport const selectors = {\n\titem: '.js-scroll-appear',\n\tcontainer: '.js-scroll-appear__container',\n} as const;\n\nexport const attributes = {\n\tstate: 'data-scroll-appear-state',\n\tdelay: 'data-scroll-appear-delay',\n\tqueue: 'data-scroll-appear-queue',\n} as const;\n","export enum ScrollAppearState {\n\tUNINITIALISED = 'uninitialised',\n\tHIDDEN = 'hidden',\n\tAPPEARING = 'appearing',\n\tVISIBLE = 'visible'\n}\n\nexport function isScrollAppearState(val: unknown): val is ScrollAppearState {\n\tconst states = Object.values(ScrollAppearState);\n\n\t// Use `as unknown[]` so TypeScript doesn't complain about using\n\t// `Array.prototype.includes` to check if an `unknown` value is included\n\treturn (states as unknown[]).includes(val);\n}\n","import { ScrollAppearState } from './ScrollAppearState.js';\nimport { ScrollAppearItem } from './ScrollAppearItem.js';\n\nexport class ScrollAppearQueue {\n\t#items: ScrollAppearItem[];\n\t#timeout: ReturnType<typeof setTimeout> | null;\n\t#delayRemovalTimeout: ReturnType<typeof setTimeout> | null;\n\t#lastItemDelay: number;\n\n\tconstructor() {\n\t\tthis.#items = [];\n\t\tthis.#timeout = null;\n\t\tthis.#delayRemovalTimeout = null;\n\t\tthis.#lastItemDelay = 0;\n\t}\n\n\t/**\n\t * Add a new item to the end of the queue if it's not in there already\n\t */\n\tpush(item: ScrollAppearItem): void {\n\t\tif (this.#isInQueue(item)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the item is hidden, add it to the queue and schedule its appearance\n\t\tif (item.getState() === ScrollAppearState.HIDDEN) {\n\t\t\tthis.#items.push(item);\n\t\t\tthis.#scheduleAppearance();\n\t\t}\n\t}\n\n\t/**\n\t * Immediately show any items that have left the viewport\n\t */\n\tcatchUp(): void {\n\t\tfor (let i = 0; i < this.#items.length; i++) {\n\t\t\tconst item = this.#items[i];\n\n\t\t\tif (item.isInViewport() === false) {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// If the first item should appepar, make it appear like normal\n\t\t\t\t\tthis.#appearFirstItem();\n\t\t\t\t} else {\n\t\t\t\t\t// If a later item should appear immediately, remove it from\n\t\t\t\t\t// the queue and make it appear immediately\n\t\t\t\t\tthis.#items.splice(i, 1);\n\t\t\t\t\titem.appear();\n\t\t\t\t}\n\n\t\t\t\t// Either way, the item was removed from the list,\n\t\t\t\t// so decrement `i` to make sure we don't miss an item\n\t\t\t\ti -= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if an item is already in the queue\n\t */\n\t#isInQueue(item: ScrollAppearItem): boolean {\n\t\tconst inQueue = this.#items.includes(item);\n\n\t\treturn inQueue;\n\t}\n\n\t/**\n\t * Schedule the appearance of the first item in the queue\n\t */\n\t#scheduleAppearance(): void {\n\t\t// If the queue is empty, remove any delay for the next appearance\n\t\tif (this.#items.length === 0) {\n\t\t\tthis.#delayRemovalTimeout = setTimeout(() => {\n\t\t\t\tthis.#lastItemDelay = 0;\n\t\t\t\tthis.#delayRemovalTimeout = null;\n\t\t\t}, this.#lastItemDelay);\n\t\t\treturn;\n\t\t}\n\n\t\t// If the next item is already scheduled to appear, do nothing\n\t\tif (this.#timeout !== null) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#timeout = setTimeout(() => this.#appearFirstItem(), this.#lastItemDelay);\n\t}\n\n\t/**\n\t * Make the first item in the queue appear\n\t */\n\t#appearFirstItem(): void {\n\t\t// If we were waiting to remove the delay for the next item,\n\t\t// stop because it's no longer relevant\n\t\tif (this.#delayRemovalTimeout) {\n\t\t\tclearTimeout(this.#delayRemovalTimeout);\n\t\t\tthis.#delayRemovalTimeout = null;\n\t\t}\n\n\t\t// If we were waiting to display the next item,\n\t\t// stop because it's happening now\n\t\tif (this.#timeout) {\n\t\t\tclearTimeout(this.#timeout);\n\t\t}\n\t\tthis.#timeout = null;\n\n\t\tlet firstItem = this.#items.shift();\n\n\t\t// If the first item has appeared already, try the next one\n\t\twhile (firstItem?.getState() === ScrollAppearState.VISIBLE) {\n\t\t\tfirstItem = this.#items.shift();\n\t\t}\n\n\t\tif (firstItem) {\n\t\t\tfirstItem.appear();\n\t\t\tthis.#lastItemDelay = firstItem.delay;\n\t\t\tthis.#scheduleAppearance();\n\t\t}\n\t}\n}\n","import { ScrollAppearQueue } from './ScrollAppearQueue.js';\n\nconst queues: Map<Document | Element | string, ScrollAppearQueue> = new Map();\n\nconst globalQueue = new ScrollAppearQueue();\nqueues.set(document, globalQueue);\n\nexport function getQueue(identifier: Document | Element | string = document): ScrollAppearQueue {\n\tconst queue = queues.get(identifier) || new ScrollAppearQueue();\n\n\tif (queues.has(identifier) === false) {\n\t\tqueues.set(identifier, queue);\n\t}\n\n\treturn queue;\n}\n\nexport function getAllQueues(): ScrollAppearQueue[] {\n\tconst allQueues: ScrollAppearQueue[] = [];\n\n\tfor (const map of queues.values()) {\n\t\tallQueues.push(map);\n\t}\n\n\treturn allQueues;\n}\n","import { isScrollAppearState } from './ScrollAppearState.js';\nimport {\n\tselectors,\n\tattributes,\n} from './domMap.js';\nimport { ScrollAppearState } from './ScrollAppearState.js';\n\nimport { getQueue } from './queues.js';\nimport { ScrollAppearQueue } from './ScrollAppearQueue.js';\n\n/**\n * This `Map` is used to store each `ScrollAppearItem` created against\n * the `Element` used to instantiate it, so we can ensure no `Element`\n * ever has more than one `ScrollAppearItem` created for it.\n */\nconst scrollAppearItems: Map<Element, ScrollAppearItem> = new Map();\n\n/**\n * Create or retrieve a `ScrollAppearItem` for a specified `Element`.\n * This function should be used in place of the `ScrollAppearItem` constructor,\n * because this class uses a singleton-like pattern to ensure each `Element`\n * can only have a single `ScrollAppearItem` created for it.\n */\nexport function getScrollAppearItem($element: Element): ScrollAppearItem {\n\tconst existingItem = scrollAppearItems.get($element);\n\tif (existingItem) {\n\t\treturn existingItem;\n\t}\n\n\tconst newItem = new ScrollAppearItem($element);\n\treturn newItem;\n}\n\nclass ScrollAppearItem {\n\t#$element: Element;\n\n\tconstructor($element: Element) {\n\t\tif (scrollAppearItems.has($element)) {\n\t\t\tthrow new Error('Cannot create a second `ScrollAppearItem` for the same `Element`');\n\t\t} else {\n\t\t\tscrollAppearItems.set($element, this);\n\t\t}\n\n\t\tthis.#$element = $element;\n\n\t\tif (this.getState() === ScrollAppearState.UNINITIALISED) {\n\t\t\tthis.#setState(ScrollAppearState.HIDDEN);\n\t\t}\n\n\t\t// Make this item appear as soon as it or any of its descendants receive focus\n\t\tthis.#$element.addEventListener('focusin', () => this.appear(), { once: true });\n\t}\n\n\tget delay(): number {\n\t\treturn Number(this.#$element.getAttribute(attributes.delay)) || 0;\n\t}\n\n\t/**\n\t * Checks if a `ScrollAppearItem`'s `Element` is in the viewport.\n\t * Only checks vertical boundaries, not horizontal.\n\t */\n\tisInViewport(threshold: number = 0): boolean {\n\t\tconst windowHeight = window.innerHeight;\n\t\tconst maxThreshold = (windowHeight / 2) - 50;\n\t\tif (threshold > maxThreshold) {\n\t\t\tthreshold = maxThreshold;\n\t\t}\n\n\t\tconst coords = this.#$element.getBoundingClientRect();\n\n\t\tconst viewportHeight = window.innerHeight || document.documentElement.clientWidth;\n\t\tconst viewportTop = threshold;\n\t\tconst viewportBottom = viewportHeight - threshold;\n\n\t\t// Is the bottom of the element below the top of the viewport?\n\t\tconst belowTop = coords.bottom >= viewportTop;\n\n\t\t// Is the top of the element above the bottom of the viewport?\n\t\tconst aboveBottom = coords.top <= viewportBottom;\n\n\t\tconst inViewport = belowTop && aboveBottom;\n\n\t\treturn inViewport;\n\t}\n\n\t/**\n\t * Make an element appear\n\t */\n\tappear(): void {\n\t\tif (this.getState() === ScrollAppearState.VISIBLE) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (matchMedia('(prefers-reduced-motion)').matches) {\n\t\t\t// Don't bother with the intermediate `APPEARING` state if the user prefers reduced motion\n\t\t\tthis.#setState(ScrollAppearState.VISIBLE);\n\t\t} else {\n\t\t\tthis.#setState(ScrollAppearState.APPEARING);\n\n\t\t\tif (getComputedStyle(this.#$element).transitionDuration !== '0s') {\n\t\t\t\t// If the `APPEARING` state has a transition duration, update the state when the transition ends\n\t\t\t\tthis.#$element.addEventListener('transitionend', () => this.#setState(ScrollAppearState.VISIBLE), { once: true });\n\t\t\t} else {\n\t\t\t\t// Otherwise, update the state immediately\n\t\t\t\tthis.#setState(ScrollAppearState.VISIBLE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Update the DOM to reflect a new `ScrollAppearState`\n\t */\n\t#setState(state: ScrollAppearState): void {\n\t\tthis.#$element.setAttribute(attributes.state, state);\n\t}\n\n\t/**\n\t * Query the DOM to retrieve the current `ScrollAppearState`\n\t */\n\tgetState(): ScrollAppearState {\n\t\tconst state = this.#$element.getAttribute(attributes.state);\n\n\t\tif (isScrollAppearState(state)) {\n\t\t\treturn state;\n\t\t} else {\n\t\t\treturn ScrollAppearState.UNINITIALISED;\n\t\t}\n\t}\n\n\t/**\n\t * Find an item's appropriate `ScrollAppearQueue`\n\t */\n\t#findQueue(): ScrollAppearQueue {\n\t\t// First, check if the queue ID is specified via an attribute\n\t\tconst queueId = this.#$element.getAttribute(attributes.queue);\n\t\tif (queueId) {\n\t\t\treturn getQueue(queueId);\n\t\t}\n\n\t\t// Then, check if the item is inside a container\n\t\tconst $container = this.#$element.closest(selectors.container);\n\t\tif ($container) {\n\t\t\treturn getQueue($container);\n\t\t}\n\n\t\t// Otherwise, return the default queue\n\t\treturn getQueue();\n\t}\n\n\t/**\n\t * Find an item's appropriate queue and add it\n\t */\n\tqueue(): void {\n\t\tconst queue = this.#findQueue();\n\n\t\tqueue.push(this);\n\t}\n}\n\n// This pattern allows the type of `ScrollAppearItem` to be exported\n// without also exporting its constructor\ntype ScrollAppearItemType = InstanceType<typeof ScrollAppearItem>;\nexport { ScrollAppearItemType as ScrollAppearItem };\n\n/**\n * This `MutationObserver` is used to forget about `Element`s that have been\n * removed from the DOM, so the `scrollAppearItems` `Map` won't prevent them\n * from being garbage collected.\n *\n * If an `Element` is removed from the DOM then added back again later, it will\n * be re-initialised.\n */\nconst scrollAppearItemObserver = new MutationObserver(_checkRemovedElements);\n\n/**\n * Whenever `Node`s are added or removed from the DOM, look for any\n * `Element`s used as keys in `scrollAppearItems` that have been removed\n * without also having been added, and remove any found from the `Map` so\n * they can be garbage collected.\n */\nfunction _checkRemovedElements(mutations: MutationRecord[], observer: MutationObserver): void {\n\t// Instead of collating all removed `Node`s and their descendants that exist\n\t// in `scrollAppearItems` and haven't also been added elsewhere, just check\n\t// if each `Element` key in `scrollAppearItems` is still in the DOM.\n\tfor (const $element of scrollAppearItems.keys()) {\n\t\tif (document.body.contains($element) === false) {\n\t\t\tscrollAppearItems.delete($element);\n\t\t}\n\t}\n}\n\nscrollAppearItemObserver.observe(document, {\n\tchildList: true,\n\tsubtree: true,\n});\n","import { throttleWithDebounce } from '@cipscis/throttle-with-debounce';\n\nimport passiveSupported from './eventListenerPassiveSupport.js';\n\nimport { selectors } from './domMap.js';\nimport { ScrollAppearState } from './ScrollAppearState.js';\n\nimport {\n\tScrollAppearItem,\n\tgetScrollAppearItem,\n} from './ScrollAppearItem.js';\nimport { getAllQueues } from './queues.js';\n\n/** (milliseconds) Throttle/debounce delay for scroll and resize events */\nconst delay = 200;\n\n/**\n * This `MutationObserver` watches for any new elements added to the page,\n * and if it finds any then it initialises any `ScrollAppearItem` elements.\n */\nconst observer = new MutationObserver(_checkNewElements);\n\n/**\n * Initialise ScrollAppear items and functionality\n */\nfunction init(): void {\n\t_initAndQueueItems();\n\t_initEvents();\n\t_initObserver();\n}\n\n/**\n * Show elements in the viewport any time the viewport changes through\n * scrolling or resizing.\n */\nfunction _initEvents(): void {\n\tconst passiveOptions = passiveSupported ? { passive: true } : true;\n\n\tconst throttledShow = throttleWithDebounce(_initAndQueueItemsEvent, delay);\n\n\twindow.addEventListener('scroll', throttledShow, passiveOptions);\n\twindow.addEventListener('resize', throttledShow, passiveOptions);\n\n\tconst throttledCatchUp = throttleWithDebounce(_catchUpQueue, delay);\n\n\twindow.addEventListener('scroll', throttledCatchUp, passiveOptions);\n\twindow.addEventListener('resize', throttledCatchUp, passiveOptions);\n}\n\n/**\n * Tell `observer` to start watching the entire DOM for `Node` insertion\n */\nfunction _initObserver(): void {\n\tobserver.observe(document, {\n\t\tchildList: true,\n\t\tsubtree: true,\n\t});\n}\n\n/**\n * If any new `Element`s have been added, initialise any new `ScrollAppearItem`s\n */\nfunction _checkNewElements(mutations: MutationRecord[], oberver: MutationObserver): void {\n\tlet nodesAdded = false;\n\n\tfor (const mutation of mutations) {\n\t\tif (mutation.addedNodes.length > 0) {\n\t\t\tnodesAdded = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nodesAdded === true) {\n\t\tconst $elements = document.querySelectorAll(selectors.item);\n\t\tif ($elements.length > 0) {\n\t\t\t_initAndQueueItems($elements);\n\t\t}\n\t}\n}\n\n/**\n * Initialise all items, optionally limited to a set of elements,\n * then queue all of them that are currently in the viewport\n */\nfunction _initAndQueueItems($elements?: ArrayLike<Element>): void {\n\tconst items = _initElements($elements);\n\t_queueHiddenItemsInViewport(items);\n}\n\n/**\n * A variation of `_initAndQueueItems` meant to be bound to events\n */\nfunction _initAndQueueItemsEvent(e: Event): void {\n\t_initAndQueueItems();\n}\n\n/**\n * Retrieve the `ScrollAppearItem` for each `Element`. If they don't\n * already have a `ScrollAppearItem`, creating one will initialise them\n */\nfunction _initElements($elements?: ArrayLike<Element>): ScrollAppearItem[] {\n\tif (!$elements) {\n\t\t$elements = document.querySelectorAll(selectors.item);\n\t}\n\n\tconst items = Array.from($elements).map(getScrollAppearItem);\n\n\treturn items;\n}\n\n/**\n * For each hidden item in the viewport, add it to the appropriate queue\n */\nfunction _queueHiddenItemsInViewport(items: ScrollAppearItem[]): void {\n\tconst hiddenItems = items.filter((item) => item.getState() === ScrollAppearState.HIDDEN);\n\n\tconst hiddenItemsInViewport = hiddenItems.filter((item) => item.isInViewport());\n\n\thiddenItemsInViewport.forEach((item) => item.queue());\n}\n\n/**\n * Tell the queues to \"catch up\" with the viewport\n */\nfunction _catchUpQueue(): void {\n\tconst queues = getAllQueues();\n\n\tfor (const queue of queues) {\n\t\tqueue.catchUp();\n\t}\n}\n\n// Self-initialise\ninit();\n","import '@cipscis/scroll-appear';\n\nwindow.setTimeout(() => {\n\tconst $element = document.createElement('div');\n\t$element.classList.add('js-scroll-appear');\n\t$element.classList.add('example');\n\t$element.setAttribute('data-scroll-appear-queue', 'example-queue');\n\n\tconst $grids = document.querySelectorAll('.example__grid');\n\tif ($grids.length) {\n\t\t$grids[$grids.length-1].appendChild($element);\n\t}\n}, 2000);\n"],"names":["throttleWithDebounce","fn","delay","throttleTimeout","debounceTimeout","args","clearTimeout","setTimeout","apply","this","passiveSupported","options","passive","noop","window","addEventListener","removeEventListener","e","selectors","attributes","ScrollAppearState","ScrollAppearQueue","constructor","push","item","getState","HIDDEN","catchUp","i","length","isInViewport","splice","appear","includes","firstItem","shift","VISIBLE","queues","Map","globalQueue","getQueue","identifier","document","queue","get","has","set","getAllQueues","allQueues","map","values","scrollAppearItems","getScrollAppearItem","$element","existingItem","ScrollAppearItem","Error","UNINITIALISED","once","Number","getAttribute","threshold","maxThreshold","innerHeight","coords","getBoundingClientRect","viewportTop","viewportBottom","documentElement","clientWidth","belowTop","bottom","aboveBottom","top","matchMedia","matches","APPEARING","getComputedStyle","transitionDuration","state","setAttribute","val","Object","queueId","$container","closest","MutationObserver","mutations","observer","keys","body","contains","delete","observe","childList","subtree","oberver","nodesAdded","mutation","addedNodes","$elements","querySelectorAll","_initAndQueueItems","items","Array","from","_initElements","filter","forEach","_queueHiddenItemsInViewport","_initAndQueueItemsEvent","_catchUpQueue","passiveOptions","throttledShow","throttledCatchUp","_initEvents","createElement","classList","add","$grids","appendChild"],"sourceRoot":""}