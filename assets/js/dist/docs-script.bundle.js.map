{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/scroll-appear/./node_modules/@cipscis/throttle/dist/throttle.js","webpack://@cipscis/scroll-appear/./node_modules/@cipscis/debounce/dist/debounce.js","webpack://@cipscis/scroll-appear/./src/eventListenerPassiveSupport.ts","webpack://@cipscis/scroll-appear/./src/domMap.ts","webpack://@cipscis/scroll-appear/./src/ScrollAppearState.ts","webpack://@cipscis/scroll-appear/./src/ScrollAppearItem.ts","webpack://@cipscis/scroll-appear/./src/scroll-appear.ts","webpack://@cipscis/scroll-appear/./src/ScrollAppearQueue.ts","webpack://@cipscis/scroll-appear/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["/**\r\n * Create a version of fn that will only execute if it\r\n * hasn't been called successfully within the last delay ms\r\n *\r\n * @param {Function} fn - A function to throttle\r\n * @param {number} delay - The duration to wait before the function can be called again (ms)\r\n */\r\nconst throttle = function (fn, delay) {\r\n    // Use ReturnType<typeof setTimeout> for support across ES and NodeJS environments\r\n    let timeout;\r\n    return function (...args) {\r\n        if (!timeout) {\r\n            const returnVal = fn.apply(this, args);\r\n            timeout = setTimeout(() => {\r\n                timeout = undefined;\r\n            }, delay);\r\n            return returnVal;\r\n        }\r\n    };\r\n};\r\nexport { throttle };\r\nexport default throttle;\r\n//# sourceMappingURL=throttle.js.map","/**\r\n * Create a version of fn that will execute only after\r\n * no attempt to call it has been made for delay ms.\r\n * The debounced function returns a Promise that\r\n * resolves to the value returned by fn.\r\n *\r\n * Note that this will uncouple the callback from user\r\n * input, if used as an event callback. This can cause\r\n * browsers to attempt to block certain behaviour.\r\n *\r\n * This throttling is useful, for example, for waiting until\r\n * the user has stopped typing before executing a keyup callback.\r\n *\r\n * @param {Function} fn - A function to debounce\r\n * @param {number} delay - The duration to wait before calling the function (ms)\r\n */\r\nconst debounce = function (fn, delay) {\r\n    // Keep track of the timeout, Promise, and the Promise's resolver across multiple calls\r\n    // This lets later calls in the same queue know about the previous call,\r\n    // to cancel its timeout and use the same promise and resolution\r\n    // Use ReturnType<typeof setTimeout> for support across ES and NodeJS environments\r\n    let timeout;\r\n    let promise;\r\n    let res;\r\n    return function (...args) {\r\n        const scheduleResolution = (resolve) => {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n            }\r\n            timeout = setTimeout(() => {\r\n                timeout = undefined;\r\n                promise = undefined;\r\n                res = undefined;\r\n                resolve(fn.apply(this, args));\r\n            }, delay);\r\n        };\r\n        if (res) {\r\n            scheduleResolution(res);\r\n        }\r\n        else {\r\n            promise = new Promise((resolve, reject) => {\r\n                res = resolve;\r\n                scheduleResolution(res);\r\n            });\r\n        }\r\n        // There is no type guard for promise on the `if (res)` path,\r\n        // but if res is not undefined, then neither is promise\r\n        return promise;\r\n    };\r\n};\r\nexport { debounce };\r\nexport default debounce;\r\n//# sourceMappingURL=debounce.js.map","/**\n * Some older browsers don't support passing an options object to `addEventListener`,\n * instead expecting a booolean value to tell them if the event is passive. To detect\n * how the current browser expects to tell if an event is passive, temporarily bind\n * a dummy event that passes an object with a getter in its `passive` property so we\n * can detect if the browser tried to access it.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#safely_detecting_option_support\n */\nlet passiveSupported = false;\ntry {\n\tconst options = {\n\t\tget passive() {\n\t\t\tpassiveSupported = true;\n\t\t\treturn false;\n\t\t},\n\t} as EventListenerOptions;\n\n\tconst noop = () => {};\n\n\twindow.addEventListener('test', noop, options);\n\twindow.removeEventListener('test', noop);\n} catch (e) {\n\tpassiveSupported = false;\n}\n\nexport default passiveSupported;\n","// These objects contain constants used to map information\n// between the DOM and our model.\n\nexport const selectors = {\n\titem: '.js-scroll-appear',\n} as const;\n\nexport const attributes = {\n\tstate: 'data-scroll-appear-state',\n\tdelay: 'data-scroll-appear-delay',\n} as const;\n","export enum ScrollAppearState {\n\tUNINITIALISED = 'uninitialised',\n\tHIDDEN = 'hidden',\n\tVISIBLE = 'visible'\n}\n\nexport function isScrollAppearState(val: unknown): val is ScrollAppearState {\n\tconst states = Object.values(ScrollAppearState);\n\n\t// Use `as unknown[]` so TypeScript doesn't complain about using\n\t// `Array.prototype.includes` to check if an `unknown` value is included\n\treturn (states as unknown[]).includes(val);\n}\n","import { isScrollAppearState } from './ScrollAppearState.js';\nimport { attributes } from './domMap.js';\nimport { ScrollAppearState } from './ScrollAppearState.js';\n\n/**\n * This `Map` is used to store each `ScrollAppearItem` created against\n * the `Element` used to instantiate it, so we can ensure no `Element`\n * ever has more than one `ScrollAppearItem` created for it.\n */\nconst scrollAppearItems: Map<Element, ScrollAppearItem> = new Map();\n\n/**\n * Create or retrieve a `ScrollAppearItem` for a specified `Element`.\n * This function should be used in place of the `ScrollAppearItem` constructor,\n * because this class uses a singleton-like pattern to ensure each `Element`\n * can only have a single `ScrollAppearItem` created for it.\n */\nexport function getScrollAppearItem($element: Element): ScrollAppearItem {\n\treturn scrollAppearItems.get($element) || new ScrollAppearItem($element);\n}\n\nclass ScrollAppearItem {\n\t#$element: Element;\n\tdelay: number;\n\n\tconstructor($element: Element) {\n\t\tif (scrollAppearItems.has($element)) {\n\t\t\tthrow new Error('Cannot create a second `ScrollAppearItem` for the same `Element`');\n\t\t} else {\n\t\t\tscrollAppearItems.set($element, this);\n\t\t}\n\n\t\tthis.#$element = $element;\n\t\tthis.delay = Number($element.getAttribute(attributes.delay)) || 0;\n\n\t\tif (this.getState() === ScrollAppearState.UNINITIALISED) {\n\t\t\tthis.#setState(ScrollAppearState.HIDDEN);\n\t\t}\n\n\t\t// Make this item appear as soon as it or any of its descendents receive focus\n\t\tthis.#$element.addEventListener('focusin', () => this.appear(), { once: true });\n\t}\n\n\t/**\n\t * Checks if a `ScrollAppearItem`'s `Element` is in the viewport.\n\t * Only checks vertical boundaries, not horizontal.\n\t */\n\tisInViewport(threshold: number = 0): boolean {\n\t\tconst windowHeight = window.innerHeight;\n\t\tconst maxThreshold = (windowHeight / 2) - 50;\n\t\tif (threshold > maxThreshold) {\n\t\t\tthreshold = maxThreshold;\n\t\t}\n\n\t\tconst coords = this.#$element.getBoundingClientRect();\n\n\t\tconst viewportHeight = window.innerHeight || document.documentElement.clientWidth;\n\t\tconst viewportTop = threshold;\n\t\tconst viewportBottom = viewportHeight - threshold;\n\n\t\t// Is the bottom of the element below the top of the viewport?\n\t\tconst belowTop = coords.bottom >= viewportTop;\n\n\t\t// Is the top of the element above the bottom of the viewport?\n\t\tconst aboveBottom = coords.top <= viewportBottom;\n\n\t\tconst inViewport = belowTop && aboveBottom;\n\n\t\treturn inViewport;\n\t}\n\n\tappear(): void {\n\t\tthis.#setState(ScrollAppearState.VISIBLE);\n\t}\n\n\t#setState(state: ScrollAppearState): void {\n\t\tthis.#$element.setAttribute(attributes.state, state);\n\t}\n\n\tgetState(): ScrollAppearState {\n\t\tconst state = this.#$element.getAttribute(attributes.state);\n\n\t\tif (isScrollAppearState(state)) {\n\t\t\treturn state;\n\t\t} else {\n\t\t\treturn ScrollAppearState.UNINITIALISED;\n\t\t}\n\t}\n}\n\n// This pattern allows the type of `ScrollAppearItem` to be exported\n// without also exporting its constructor\ntype ScrollAppearItemType = InstanceType<typeof ScrollAppearItem>;\nexport { ScrollAppearItemType as ScrollAppearItem };\n","import { throttle } from '@cipscis/throttle';\nimport { debounce } from '@cipscis/debounce';\n\nimport passiveSupported from './eventListenerPassiveSupport.js';\n\nimport { selectors } from './domMap.js';\nimport { ScrollAppearState } from './ScrollAppearState.js';\n\nimport { getScrollAppearItem } from './ScrollAppearItem.js';\nimport { ScrollAppearQueue } from './ScrollAppearQueue.js';\n\n// TODO: Improve initialisation/default styles so there is never an initial flash, without compromising no-js functionality\n\n/** (milliseconds) Throttle/debounce delay for scroll and resize events */\nconst delay = 100;\n\nconst queue = new ScrollAppearQueue();\n\n/**\n * Initialise ScrollAppear for a particular set of elements\n */\nexport function init($container: Element | Document = document): void {\n\t_initElements($container);\n\n\t_initEvents();\n}\n\n/**\n * Find all scroll appear elements and initialise them. Then, show any elements within the viewport\n */\nfunction _initElements($container: Element | Document = document): void {\n\tconst $elements = Array.from($container.querySelectorAll(selectors.item));\n\n\t$elements.forEach(_initElement);\n\n\t_queueElementsInViewport();\n}\n\n/**\n * Create a `ScrollAppearItem` for an `Element`, letting its constructor perform the necessary initialisation.\n * We can retrieve the same `ScrollAppearItem` later, so we don't need to remember it now.\n */\nfunction _initElement($element: Element): void {\n\tgetScrollAppearItem($element);\n}\n\n/**\n * Show elements in the viewport any time the viewport changes through\n * scrolling or resizing.\n */\nfunction _initEvents(): void {\n\tconst passiveOptions = passiveSupported ? { passive: true } : true;\n\n\t// TODO: Bind events in a way that prevents a single scroll or resize event from firing the handler twice\n\tconst throttledShow = throttle(_queueElementsInViewport, delay);\n\tconst debouncedShow = debounce(_queueElementsInViewport, delay);\n\n\twindow.addEventListener('scroll', throttledShow, passiveOptions);\n\twindow.addEventListener('scroll', debouncedShow, passiveOptions);\n\n\twindow.addEventListener('resize', throttledShow, passiveOptions);\n\twindow.addEventListener('resize', debouncedShow, passiveOptions);\n\n\tconst throttledCatchUp = throttle(_catchUpQueue, delay);\n\tconst debouncedCatchUp = debounce(_catchUpQueue, delay);\n\n\twindow.addEventListener('scroll', throttledCatchUp, passiveOptions);\n\twindow.addEventListener('scroll', debouncedCatchUp, passiveOptions);\n\n\twindow.addEventListener('resize', throttledCatchUp, passiveOptions);\n\twindow.addEventListener('resize', debouncedCatchUp, passiveOptions);\n}\n\n/**\n * Add all hidden elements in the viewport to the queue\n */\nfunction _queueElementsInViewport(): void {\n\tconst $elements = Array.from(document.querySelectorAll(selectors.item));\n\tconst items = $elements.map(getScrollAppearItem);\n\tconst hiddenItems = items.filter((item) => item.getState() === ScrollAppearState.HIDDEN);\n\n\tconst hiddenItemsInViewport = hiddenItems.filter((item) => item.isInViewport());\n\n\thiddenItemsInViewport.forEach((item) => queue.push(item));\n}\n\n/**\n * Tell the queue to \"catch up\" with the viewport\n */\nfunction _catchUpQueue(): void {\n\tqueue.catchUp();\n}\n","import { ScrollAppearState } from './ScrollAppearState.js';\nimport { ScrollAppearItem } from './ScrollAppearItem.js';\n\n// TODO: Allow for multiple queues, based either on an ID in a data attribute or a containing element\n\nexport class ScrollAppearQueue {\n\t#items: ScrollAppearItem[];\n\t#timeout: ReturnType<typeof setTimeout> | null;\n\t#delayRemovalTimeout: ReturnType<typeof setTimeout> | null;\n\t#lastItemDelay: number;\n\n\tconstructor() {\n\t\tthis.#items = [];\n\t\tthis.#timeout = null;\n\t\tthis.#delayRemovalTimeout = null;\n\t\tthis.#lastItemDelay = 0;\n\t}\n\n\t/**\n\t * Add a new item to the end of the queue if it's not in there already\n\t */\n\tpush(item: ScrollAppearItem): void {\n\t\tif (this.#isInQueue(item)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the item is hidden, add it to the queue and schedule its appearance\n\t\tif (item.getState() === ScrollAppearState.HIDDEN) {\n\t\t\tthis.#items.push(item);\n\t\t\tthis.#scheduleAppearance();\n\t\t}\n\t}\n\n\t/**\n\t * Immediately show any items that have left the viewport\n\t */\n\tcatchUp(): void {\n\t\tfor (let i = 0; i < this.#items.length; i++) {\n\t\t\tconst item = this.#items[i];\n\n\t\t\tif (item.isInViewport() === false) {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// If the first item should appepar, make it appear like normal\n\t\t\t\t\tthis.#appearFirstItem();\n\t\t\t\t} else {\n\t\t\t\t\t// If a later item should appear immediately, remove it from\n\t\t\t\t\t// the queue and make it appear immediately\n\t\t\t\t\tthis.#items.splice(i, 1);\n\t\t\t\t\titem.appear();\n\t\t\t\t}\n\n\t\t\t\t// Either way, the item was removed from the list,\n\t\t\t\t// so decrement `i` to make sure we don't miss an item\n\t\t\t\ti -= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if an item is already in the queue\n\t */\n\t#isInQueue(item: ScrollAppearItem): boolean {\n\t\tconst inQueue = this.#items.includes(item);\n\n\t\treturn inQueue;\n\t}\n\n\t/**\n\t * Schedule the appearance of the first item in the queue\n\t */\n\t#scheduleAppearance(): void {\n\t\t// If the queue is empty, remove any delay for the next appearance\n\t\tif (this.#items.length === 0) {\n\t\t\tthis.#delayRemovalTimeout = setTimeout(() => {\n\t\t\t\tthis.#lastItemDelay = 0;\n\t\t\t\tthis.#delayRemovalTimeout = null;\n\t\t\t}, this.#lastItemDelay);\n\t\t\treturn;\n\t\t}\n\n\t\t// If the next item is already scheduled to appear, do nothing\n\t\tif (this.#timeout !== null) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#timeout = setTimeout(() => this.#appearFirstItem(), this.#lastItemDelay);\n\t}\n\n\t/**\n\t * Make the first item in the queue appear\n\t */\n\t#appearFirstItem(): void {\n\t\t// If we were waiting to remove the delay for the next item,\n\t\t// stop because it's no longer relevant\n\t\tif (this.#delayRemovalTimeout) {\n\t\t\tclearTimeout(this.#delayRemovalTimeout);\n\t\t\tthis.#delayRemovalTimeout = null;\n\t\t}\n\n\t\t// If we were waiting to display the next item,\n\t\t// stop because it's happening now\n\t\tif (this.#timeout) {\n\t\t\tclearTimeout(this.#timeout);\n\t\t}\n\t\tthis.#timeout = null;\n\n\t\tlet firstItem = this.#items.shift();\n\n\t\t// If the first item has appeared already, try the next one\n\t\twhile (firstItem?.getState() === ScrollAppearState.VISIBLE) {\n\t\t\tfirstItem = this.#items.shift();\n\t\t}\n\n\t\tif (firstItem) {\n\t\t\tfirstItem.appear();\n\t\t\tthis.#lastItemDelay = firstItem.delay;\n\t\t\tthis.#scheduleAppearance();\n\t\t}\n\t}\n}\n","import { init } from '@cipscis/scroll-appear';\n\ninit();\n"],"names":["throttle","fn","delay","timeout","args","returnVal","apply","this","setTimeout","undefined","debounce","promise","res","scheduleResolution","resolve","clearTimeout","Promise","reject","passiveSupported","options","passive","noop","window","addEventListener","removeEventListener","e","selectors","attributes","ScrollAppearState","scrollAppearItems","Map","getScrollAppearItem","$element","get","ScrollAppearItem","constructor","has","Error","set","Number","getAttribute","getState","UNINITIALISED","HIDDEN","appear","once","isInViewport","threshold","maxThreshold","innerHeight","coords","getBoundingClientRect","viewportTop","viewportBottom","document","documentElement","clientWidth","belowTop","bottom","aboveBottom","top","VISIBLE","state","setAttribute","val","Object","values","includes","queue","push","item","catchUp","i","length","splice","firstItem","shift","_initElement","_queueElementsInViewport","Array","from","querySelectorAll","map","filter","forEach","_catchUpQueue","$container","_initElements","passiveOptions","throttledShow","debouncedShow","throttledCatchUp","debouncedCatchUp","_initEvents","init"],"sourceRoot":""}